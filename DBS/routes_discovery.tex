% Emacs, this is -*-latex-*-

% Routes Discovery and Topology Optimization

\label{sec:routes_discovery}

Chunks can be lost under bandwidth and buffering time constraints (a
chunk is lost when it is time to send it to the player, i.e. when it
is pointed by $P$, and the chunk has not been received). In this
situation, for each lost chunk, the peer sends a
$[\mathtt{request}~\text{lost\_chunk\_number}]$ to a random peer of
the team. When a peer $P_i$ receives a
$[\mathtt{request}~\text{lost\_chunk\_number}]$ from $P_j$, $P_i$ adds
$P_j$ to $\mathtt{forward}[P_k]$, where $P_k$ is the origin peer of
the chunk stored in the position
$(\text{lost\_chunk\_number}~\mathit{mod}~2B)$ of its buffer.

Chunks are also requested using a pre-fetching strategy, which has the
objective of reducing the convergence time of the overlay to its
optimal structure (i.e., to reduce as much as possible the loss of
chunks). Peers request those chunks that are in the position $P+O$ of
their buffers, where $O\geq 0$ is an optimization threshold configured
by the user. Notice that if $O=0$, the pre-fetching is disabled. The
higher the $O$, the faster the convergente but also a larger number of
requests messages will be generated, increasing the overhead of the
protocol. Notice also that $O$ can be different between peers and
variable in time.

When request messages are used, redundant routes can be created
between an origin peer and itself, and therefore, some chunks could be
received more than once. Obviously, this is also an overhead that must
be minimized. For this, for each chunk stored in the buffer there is a
set of counters that counts the number of times the chunk has been
received as a duplicate from the corresponding neighbor. When a peer
$P_i$ plays a chunk, $P_i$ send a
$[\mathtt{prune}~\text{duplicate\_chunk\_index}]$ to every neighbor
whose counter is higher than a threshold $D$ (the maximum number of
duplicates per chunk per neighbor, also controlled by the used as a
part of the optimization of the position of its peer in the overlay),
and removes the counter. Neighbors receiving this message from peer
$P_i$ remove the $P_i$ from $\mathtt{forward}[P_k]$, where $P_k$ is
the origin peer of the duplicate chunk.

In Sec.~\ref{sec:chunk_flooding} was introduced the concept of
neighborhood degree. Now, we define this value as the number of
different destination peers for each possible origin that a peer
forwards. For example, if peer $P_i$ forwards chunks from origin $P_i$
to 10 neighbors, the neighborhood degree of $P_i$ for the origin $P_i$
is 10, and if the peer $P_i$ also forwards chunks from origin $P_j$ to 5
neighbors, the neighborhood degree of $P_i$ for the origin $P_j$ is 5.

Considering the rules described before, the neighborhood degrees of
peers can decrease or increase to optimize the topology of the
overlay. An increment in the degree for the origin of a requested
chunk $\text{lost\_chunk\_number}$ in $P_i$ is produced when $P_i$
recives a $[\mathtt{request}~\text{lost\_chunk\_number}]$ from a peer
that is not a neighbor yet. On the contrary, a decrement in the degree
for the origin of a pruned chunk $\text{duplicate\_chunk\_index}$ in
$P_i$ is produced when $P_i$ receives a
$[\mathtt{prune}~\text{duplicate\_chunk\_index}]$ from a neighbor
peer, for that origin.
