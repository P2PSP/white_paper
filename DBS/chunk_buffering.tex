In order to hide the jitter generated by the physical network and the
protocol itself, peers need to store the received chunks in a buffer
before playing them. A chunk $c_x$ is inserted in the position
$(x \mathit{mod} B)$ of the buffer, where $B$ the buffer size in
chunks.

\subsection{Chunk routing}
\label{sec:chunk_routing}
It can happen\footnote{Especially if $P_k$ has just joined to the
  team.} that the received chunk by peer a $P_k$ from a neighbor peer
$P_i$ is a duplicate chunk. In this case, $P_k$ sends to $P_i$ a
$[\mathtt{NRFCF} x]$ ($\mathtt{N}$ot $\mathtt{R}$elay
$\mathtt{F}$uture $\mathtt{C}$hunks $\mathtt{F}$rom) message, where
$x$ is number of the duplicate chunk. Thus, only the first neighbor
$P_j$ to send to $P_k$ a chunk $x$ ``originated'' at peer $P_l$ will
do that in the future (remember that the origin peers are stored in
the chunks messages), at least that $P_k$ revokes this routing
information by sending a $[\mathtt{RFCF} x]$ ($\mathtt{R}$elay
$\mathtt{F}$uture $\mathtt{C}$hunks $\mathtt{F}$rom) to one or more
(possibly the rest of) peers of $T^k$. Notice that, in order to sucess
of this procedure, $P_i$ must have received the chunk $x$, and
otherwise, this will not have effect. Anyway, this is not a
significative drawback because these messages will be generated until
the routes have been defined correctly.

Chunks are transmited using unreliable messages, and therefore, they
can be lost. A chunk is given as lost by peer $P_k$ when it is time to
send it to the player and the chunk has not been received. In this
moment, as in the previous situation, $P_k$ sends a $[\mathtt{RFCF}
  P_m]$ to one or more (possibly the rest of) peers of $T^k$, where
$P_m$ is .
