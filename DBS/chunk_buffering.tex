%%% Local Variables:
%%% mode: latex
%%% TeX-master: "<none>"
%%% End:

\label{sec:chunk_buffering}

In order to hide the jitter generated by the physical network and the
protocol itself, peers need to store the received chunks in a buffer
before playing them. A chunk with index $x$ is inserted in the
position $(x \mathit{mod} \text{BUFFER\_SIZE})$ of the buffer, where
$\text{BUFFER\_SIZE}$ is the maximum number of chunks that the
buffer can store.

\begin{figure*}
  \fig{500}{5cm}{DBS_peer_buffering} \caption{Buffering of the
    chunks.\label{fig:DBS_peer_buffering}}
\end{figure*}

The buffer is implemented a circular queue of $\text{BUFFER\_SIZE}$
chunks, which is filled up to only $\text{BUFFER\_SIZE}/2$ chunks in
the buffering time (half of the queue is unfilled). Chunks with a
higher index are inserted in the head of the buffer. The tail of the
buffer is referenced by $\text{chunk\_to\_play}$, because this
variable determines the chunks (of the buffer) that will be sent to
the player.

The buffering time is a key feature in any streaming system because it
determines how much time the peers must wait before start playing the
chunks. Considering that chunks can be lost or delayed more than
$\text{BUFFER\_SIZE}/2$ times of chunk, randomly, it is difficult to
determine, a priori the optimal buffering time. An heuristic that
works is the described in the Fig.~\ref{fig:DBS_peer_buffering}. As
can be seen, $\text{chunk\_to\_play}$ points to the first received
chunk, that not necessary is the received chunk with lower
index.\footnote{Notice that all chunks with index smaller than
  $\text{chunk\_to\_play}$ will be discarded.} After that, the
buffering finishes when a chunk with index $\text{chunk\_to\_play} +
\text{BUFFER\_SIZE}/2$ has been received.\footnote{This not means that
  $\text{BUFFER\_SIZE}/2$ chunks are available in the buffer.}
