%%% Local Variables:
%%% mode: latex
%%% TeX-master: "<none>"
%%% End:

\label{sec:cnunk_playing}

After receiving $\text{BUFFER\_SIZE}/2$ chunks, peers send the chunks
stored in the head of the buffer, which is implemented as a circular
queue. The number of chunks sent in a burst depends on how the chunks
are disposed in the buffer. In an ideal scenario, where all chunks are
received on time\footnote{A chunks is considered as lost when it is
  time to send it to the player and the chunks has not been received.}, 


After connecting with a splitter, incoming peers request (using a
reliable communication) to the splitter the current list of peers in
the team. To minimize the joining time, the peer sends a
$[``\mathtt{hello}"]$ message to each peer of the team in parallel
with the reception of the list. When a peer of the team receives a
$[``\mathtt{hello}"]$, it runs the $\text{add\_neighbor}()$ function,
which basically adds the sender of the message to a table of peers
called $\text{forward}[]$. If a peer $P_i$ has an entry
$\text{forward}[P_j]=P_k$ then, each chunk received by $P_i$ and
originated at $P_j$ will be forwarded to $P_k$ (see
Sec.~\ref{sec:DBS_process_chunk}).

%), initializes
%the table $\mathrm{debt}[]$ (which stores the chunk debts between
%neighbor peers), and (3) sets the variable $\mathrm{neighbor}$ with an
%index to $\mathrm{forward}[]$ (see
%Sec.~\ref{sec:chunk_DBS_processing}).

The splitter, in an infinite loop: (1) listens to the peers, (2) sends
the list of peers in the team to the peers, and (3) adds the incoming peer
to the list.

\begin{figure*}
  %\includegraphics[width=\textwidth]{joining}
  \fig{1000}{10cm}{joining} \caption{Code related to team
    joining.\label{fig:joining}}
\end{figure*}

The new pseudo-code related to joining a team is describen in the
Fig.~\ref{fig:joining}.

