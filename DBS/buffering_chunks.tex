%%% Local Variables:
%%% mode: latex
%%% TeX-master: "<none>"
%%% End:

\label{sec:buffering_chunks}

In order to hide the jitter generated by the physical network and the
protocol itself, peers need to store the received chunks in a buffer
during a period of time, before sending them to a player. A chunk with
number $x$ is inserted in the position $(x~\mathit{mod}~2B)$ of the
buffer, where $B$ is the maximum number of chunks that the buffer can
store. In a peer's life, $B$ is a constant, but it is not compulsory
that all peers of a team use the same buffer size.

The buffer is implemented as a circular queue of $2B$ chunks, which is
filled up to only $B$ chunks during the \emph{buffering time} $t_B$
(which is the main part of the \emph{start-up time} that the users
experiment). Chunks with a higher number (newer chunks) are inserted
in the head of the buffer. The (received) chunk pointed by the tail of
the buffer is sent to the player. This action is carried out each time
a new chunk is received\footnote{DBS does not know nothing about the
  content and therefore, about the timing of the chunks.}. Empty cells
in the buffer (caused by the chunks that have not been received on
time) are skipped until to find the next cell with content.

$t_B$ determines how long the peers must wait for start playing the
chunks. In general, $t_B$ should be as small as possible, and to
achieve this we can reduce $t_C$ and $B$. Unfortunately, these
reductions generate another drawbacks. On the one hand, the overhead
of the header of the transport protocol is inversely proportional to
$t_C$, and therefore, $t_C$ should be selected enough large to keep
under control this overhead. On the other hand, if $B$ is to small
(for example, if $B<N$) the peer will not have enought space to buffer
all the chunks of a round, and due to the chunks are not going to be
received in order, some chunks will overwrite others before they can
be played. This problem can also happen even if $N\leq B<2N$, because
the maximum jitter for a given peer (generated by DBS) that a chunk
can experiment is the sum of the maximum jitter produced by the
splitter for this peer, that can be $N$, and the maximum jitter
produced by the team, $N$, in the case of a full-connected mesh such
as the shown in the Fig.~\ref{fig:full_mesh}. Therefore, $B=2N$ should
work well, except when the jitter of the physical network is high,
where $B$ should be larger than $2N$.

Given a $N$ value, DBS peers may buffer a different number of chunks
that depends on the order in which chunks are received. If $x_1$ is
the (number of the) first received chunk (the first chunk to be
played), the buffering time finishes when a chunk with number equal or
greater than $x_{1+B}$ is received.\footnote{Notice that all received
  chunks with an number smaller than $x_1$ will be discarded, and that
  during the buffering time, it can happens that some chunks are not
  received on time. Therefore, it does not make sense to wait for $B$
  chunks before stopping the buffering process.} Lets analyze some
interesting cases.

Lets suppose that the first received chunk is $x_1$ and that the rest
of chunks of the buffer of size $B$ are received, being the chunk
$x_{1+B}$ the last (this is the ideal scenario). In this case, the
stream can be played without artifacts. Because the playing of the
chunks starts after the buffering process, the end-latency
experimented by users would be $T=Bt_C+L$, being $L$ the latency
generated by the physical transmission media (see
Tab.~\ref{tab:DBS_nomenclature}).

Lets imagine now one of the worst possible scenarios, in which after
receiving $x_1$ the chunk $x_{1+B}$ is received. In this case, the
chunks $x_2, \cdots x_{1+B-1}$ have been lost (or delayed too much) by
the physical transmission media or the transmission protocol, but
again (and considering $t_C$ constant), the buffering time is $t_B=Bt_C$
because the chunk $x_{1+B}$ was generated $B$ chunk times after
$x_1$. Therefore, in this case the end-latency is also $T=Bt_C+L$.

After considering these two extreme situations, we can conclude that
the end-latency does not depend on the loss chunk ratio during the
buffering time (always that this ratio is smaller than one), but only
on $B$, $t_C$ and $L$.

% Hablar de la relación entre B y el tamaño del team. Tal vez, cuando
% se presente la expresión de la latencia en función del grado de
% conectividad. En el caso extremo en que todos los peers se
% conectaran con todos, B >= N^*, el número máximo de peer en el team.

\begin{comment}
An heuristic that
works is the described in the Fig.~\ref{fig:DBS_peer_buffering}. As
can be seen, $\text{chunk\_to\_play}$ points to the first received
chunk, that not necessary is the received chunk with lower
index. After that, the
buffering finishes when a chunk with index $\text{chunk\_to\_play} +
\text{BUFFER\_SIZE}/2$ has been received.\footnote{This not means that
  $\text{BUFFER\_SIZE}/2$ chunks are available in the buffer.}
\end{comment}
