<!DOCTYPE html> 
<html> 
<head> <title>P2PSP (Peer-to-Peer Straightforward Protocol)</title> 
<meta charset="UTF-8" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="index.css" /> 
<script type="text/javascript" 
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" 
></script> 
<style type="text/css"> 
.MathJax_MathML {text-indent: 0;} 
</style> 
</head><body 
>
   <div class="maketitle">
                                                                  

                                                                  
                                                                  

                                                                  

<h2 class="titleHead">P2PSP (Peer-to-Peer Straightforward Protocol)</h2>
 <div class="author" ><span 
class="ecrm-1200">The P2PSP team</span></div><br />
<div class="date" ><span 
class="ecrm-1200">August 21, 2018</span></div>
   </div>
   <div 
class="abstract" 
>
<div class="center" 
>
<!--l. 21--><p class="noindent" >
</p><!--l. 21--><p class="noindent" ><span 
class="ecbx-0900">Abstract</span></p></div>
     <!--l. 1--><p class="indent" >    <span 
class="ecrm-0900">P2PSP   (see   </span><a 
href="https://p2psp.github.io" class="url" ><span 
class="ectt-0900">https://p2psp.github.io</span></a><span 
class="ecrm-0900">)   is   an   application-layer</span>
     <span 
class="ecrm-0900">protocol that provides real-time broadcasting, also known as Application</span>
     <span 
class="ecrm-0900">Layer Multicast (ALM), of a media stream on the Internet. As in many</span>
     <span 
class="ecrm-0900">other P2P protocols, peers collaborate to diseminate the stream that is</span>
     <span 
class="ecrm-0900">generated by a single source, minimizing the latency and the protocol</span>
     <span 
class="ecrm-0900">overhead. P2PSP has a modular design organized in </span><span 
class="ecti-0900">sets of rules</span><span 
class="ecrm-0900">, where</span>
     <span 
class="ecrm-0900">each module is especialized in implementing a diﬀerent functionality.</span>
</p>
</div>
   <h3 class="likesectionHead"><a 
 id="x1-1000"></a>Contents</h3>
   <div class="tableofcontents">
   <span class="sectionToc" >1 <a 
href="#x1-20001" id="QQ2-1-2">STS (Splitters Tracking Set)</a></span>
<br />   <span class="sectionToc" >2 <a 
href="#x1-30002" id="QQ2-1-5">DBS (Data Broadcasting Set)</a></span>
<br />    <span class="subsectionToc" >2.1 <a 
href="#x1-40002.1" id="QQ2-1-7">Feeding the team</a></span>
<br />    <span class="subsectionToc" >2.2 <a 
href="#x1-50002.2" id="QQ2-1-8">Joining a team</a></span>
<br />    <span class="subsectionToc" >2.3 <a 
href="#x1-60002.3" id="QQ2-1-9">Buﬀering chunks</a></span>
<br />    <span class="subsectionToc" >2.4 <a 
href="#x1-70002.4" id="QQ2-1-10">Chunk ﬂooding</a></span>
<br />    <span class="subsectionToc" >2.5 <a 
href="#x1-80002.5" id="QQ2-1-13">Leaving a team</a></span>
<br />    <span class="subsectionToc" >2.6 <a 
href="#x1-90002.6" id="QQ2-1-14">Free-riding control at splitters</a></span>
                                                                  

                                                                  
<br />   <span class="sectionToc" >3 <a 
href="#x1-100003" id="QQ2-1-15">FCS (Free-riding Control Set)</a></span>
   </div>
<!--l. 27--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-20001"></a>STS (Splitters Tracking Set)</h3>
   <hr class="figure" /><div class="figure" 
>
                                                                  

                                                                  
<a 
 id="x1-20011"></a>
                                                                  

                                                                  
<!--l. 9--><p class="noindent" > <div style="text-align:center;"> <img width=600 src="graphics/icecast-P2PSP.png" /> </div> 
<br />  </p><div class="caption" 
><span class="id">Figure 1:  </span><span  
class="content">A  possible  data-ﬂow  in  an  hybrid  Icecast/P2PSP  network.
<!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>S</mi></math>
represents                         a                         splitter                         and
<!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math>
a peer.</span></div><!--tex4ht:label?: x1-20011 -->
                                                                  

                                                                  
   </div><hr class="endfigure" />
<!--l. 15--><p class="indent" >   P2PSP supposes that there is a collection of channels that are broadcasted in
parallel.<span class="footnote-mark"><a 
href="index2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-2002f1"></a>  The channels are
available at one or more<span class="footnote-mark"><a 
href="index3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-2003f2"></a> 
streaming <span 
class="ecti-1000">servers</span>, and each channel has a diﬀerent URL (Universal Resource
Locator), usually expressed as a Web address with the structure:
                                                                  

                                                                  
</p>
   <div class="verbatim" id="verbatim-1">
  http://name.icecast.server/name_of_the_channel
</div>
<!--l. 27--><p class="nopar" >
</p><!--l. 30--><p class="indent" >   P2PSP does not perform data-ﬂow control over the stream. The transmission
bit-rate between P2PSP entities is controlled by an external server, which provides
the stream. Fig. <a 
href="#x1-20011">1<!--tex4ht:ref: fig:icecast-P2PSP --></a> shows an example of an hybrid Icecast/P2PSP streaming overlay
where several Icecast servers relay a set of channels produced by a set of
source-clients, directly or through other servers. As can be seen, a listener (which
usually plays de stream) can be replaced by a <span 
class="ecti-1000">splitter</span>, a P2PSP entity that sends the
received stream (a single channel) to a set of P2PSP <span 
class="ecti-1000">peers</span>, called <span 
class="ecti-1000">team</span>.
Notice that, considering that a player can be attached to each peer, the
scalability of the hybrid alternative is much higher than the pure client/server
architecture.
</p><!--l. 52--><p class="indent" >   Usually, users are mainly interested in receiving channels, not in knowing the
topology of the overlay. In a pure Icecast system, users request the channels directly
to the servers. Unfortunately, this simple procedure has a drawback: normally, users
does not know the load of the servers nor their distance to the user’s player.
This problem can be solved using a <span 
class="ecti-1000">load balancer</span>. The listeners (and the
splitters) which know the URL of the required channel, connects ﬁrst to the
load balancer which redirects them (with a HTTP 302 code) to a suitable
server.
</p><!--l. 63--><p class="indent" >   This idea can be extended to take advantage of the existence of P2PSP teams in hybrid
overlays, where some users run a local peer to retrieve a copy of the stream. In this case, the peer
communicates<span class="footnote-mark"><a 
href="index4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-2004f3"></a> 
with the load balancer to tell it that there is a peer running in the same
host that the player. Thus, when the player requests to the load balancer
the reception of the stream, the load balancer redirects it towards the local
peer.<span class="footnote-mark"><a 
href="index5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-2005f4"></a> 
</p><!--l. 84--><p class="indent" >   When a network entity (usually, a player) connects with a peer, this must
connects with a splitter which is transmitting the stream selected by the user.
Depending on maximum number of potential peers that are retrieving the same
channel, more than one splitter could be available. This information is served by a
                                                                  

                                                                  
<span 
class="ecti-1000">splitters tracker</span>, and generated when a new splitter is instantiated. The
tracker keeps updated a table indexed by names of channels, where every
entry contains a list of splitters that transmit the corresponding channel.
Therefore, to ﬁnd a suitable splitter, the peer ﬁrst retrieves from the splitters
tracker a list of splitters. Then, the peer tries to connect with all the
splitters<span class="footnote-mark"><a 
href="index6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-2006f5"></a> 
in parallel, and the fastest connection determines the selected splitter (the rest of
successful connections are closed). This procedure should select the “closest” splitter
to the peer in terms of network latency.
</p><!--l. 109--><p class="indent" >   The splitters send to the tracker a message with the current number
<!--l. 110--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>t</mi></math> of
peers in their teams. When a splitters (and its team) is created, it sends a message
<!--l. 111--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi 
>t</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math> with
<!--l. 111--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>t</mi> <mo 
class="MathClass-rel">≥</mo> <msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
><mo 
class="MathClass-bin">−</mo> <mn>1</mn></math> where
<!--l. 111--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></math> is the maximum
team size<span class="footnote-mark"><a 
href="index7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-2007f6"></a> 
for that splitter (at least one monitor peer must be in each
team). When the team is full, the splitter sends a message with
<!--l. 115--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>t</mi> <mo 
class="MathClass-rel">=</mo> <mn>0</mn></math>.
When the team is shutted down, the splitter sends a
<!--l. 116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>t</mi> <mo 
class="MathClass-rel">=</mo> <mo 
class="MathClass-bin">−</mo><mn>1</mn></math>.
Using the number of free spaces in each team, the splitters tracker can perform some
load balacing among the teams, by including only those teams with more room in the
<!--l. 118--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mstyle 
class="text"><mtext  >list of splitters</mtext></mstyle></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
response.
                                                                  

                                                                  
</p><!--l. 122--><p class="indent" >   <a 
 id="x1-20082"></a></p><hr class="float" /><div class="float" 
>
                                                                  

                                                                  
 <div style="text-align:center;"> <img width=900 src="graphics/STS_example.png" /> </div> 
<br /> <div class="caption" 
><span class="id">Figure 2: </span><span  
class="content">Timeline example of an STS interaction.</span></div><!--tex4ht:label?: x1-20082 -->
                                                                  

                                                                  
   </div><hr class="endfloat" />
<!--l. 128--><p class="indent" >   The Fig. <a 
href="#x1-20082">2<!--tex4ht:ref: fig:STS_example --></a> shown an example of an STS communication. When the peer is created, it
sends a <!--l. 129--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">hello</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
message to the load balancer telling that a player is running in the same
host that the peer and therefore, the peers should be redirected towards
it. When the splitters are instantiated, they send their teams sizes
(<!--l. 133--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>1</mn></math>,
supposing that only one monitor has added to each team). The player is redirected to
the peer which, after receiving the list of splitters from the tracker, selects the
Splitter<!--l. 135--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> because answers
ﬁrst than the Splitter<!--l. 136--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
></mrow><mrow 
><mn>2</mn></mrow></msub 
></math>.
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-30002"></a>DBS (Data Broadcasting Set)</h3>
   <div class="table">
                                                                  

                                                                  
<!--l. 9--><p class="indent" >   <a 
 id="x1-30011"></a></p><hr class="float" /><div class="float" 
>
                                                                  

                                                                  
<div class="tabular"> <table id="TBL-2" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1" /><col 
id="TBL-2-2" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-1-1"  
class="td11">                                                          Parameter  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-1-2"  
class="td11"> Meaning                                       </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-2-1"  
class="td11"> <!--l. 12--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math>  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-2-2"  
class="td11"> Buﬀer size in chunks                        </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-3-1"  
class="td11"> <!--l. 13--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>C</mi></math> </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-3-2"  
class="td11"> Chunk size</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-4-1"  
class="td11"> <!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>D</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></math> </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-4-2"  
class="td11"> Maximum chunk debt between peers  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-5-1"  
class="td11"> <!--l. 15--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>L</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></math> </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-5-2"  
class="td11"> Maximum losses of chunk                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-6-1"  
class="td11"> <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>M</mi></math>  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-6-2"  
class="td11"> Number of monitors                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="text-align:right; white-space:nowrap;" id="TBL-2-7-1"  
class="td11"> <!--l. 17--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msup><mrow 
><mi 
>N</mi></mrow><mrow 
><mo 
class="MathClass-bin">∗</mo></mrow></msup 
></math> </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-7-2"  
class="td11"> Maximum number of peers in a team  </td></tr></table>
</div>
<br /> <div class="caption" 
><span class="id">Table 1: </span><span  
class="content">Nomenclature used in DBS.</span></div><!--tex4ht:label?: x1-30011 -->
                                                                  

                                                                  
   </div><hr class="endfloat" />
   </div>
<!--l. 22--><p class="indent" >   DBS provides ALM <span class="cite">[<a 
href="#Xbanerjee2002scalable">1</a>]</span> of a media stream in unicast environments <span class="cite">[<a 
href="#Xcomer2003computer">2</a>]</span>. The media
is sent by a streaming server, and received by a splitter (see Sec. <a 
href="#x1-20001">1<!--tex4ht:ref: sec:STS --></a>). The splitter divides
the stream into a sequence of <span 
class="ecti-1000">chunks</span>, and relay them to its team, where it can be up
to <!--l. 28--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>N</mi></math>
peers. Each peer gathers the chunks from the splitter and the rest of peers of the
team, and sends them to a player. The Tab. <a 
href="#x1-30011">1<!--tex4ht:ref: tab:DBS_nomenclature --></a> gathers up the deﬁnitions used in the
DBS.
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-40002.1"></a>Feeding the team</h4>
<!--l. 8--><p class="noindent" >The splitter divides the stream into chunks of constant length
<!--l. 8--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>C</mi></math>,
and sends exclusively each chunk to a diﬀerent <span 
class="ecti-1000">origin</span>
<span 
class="ecti-1000">peer</span><span class="footnote-mark"><a 
href="index8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-4001f7"></a> ,
using a round-robin schema. The teams are created with a least one monitor
peer<span class="footnote-mark"><a 
href="index9.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-4002f8"></a> 
that runs, by default, in the same host that the splitter, and listens to the port 9999.
Chunks are enumerated to distinguish them at the peers.
</p><!--l. 37--><p class="indent" >   We deﬁne a <span 
class="ecti-1000">round </span>as the process of sending a (diﬀerent) chunk from the splitter
to all the peers of the team. In other words, in a round, all peers of the team should
have received a diﬀerent chunk from the splitter. Notice that the round-time is
variable, and depends on the current number of peers in the team, the chunk-size,
and the average bit-rate of the media.
</p><!--l. 44--><p class="indent" >   The splitter remembers which chunk, of a list of the last
<!--l. 44--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math>
chunks transmitted to the team, was sent to each peer.
</p><!--l. 47--><p class="indent" >   <span 
class="ecbx-1000">Note</span>:  See <a 
href="https://github.com/P2PSP/simulator/blob/f0c73be1817e7d3b816cc61cd2c8e59b17f9a0e6/src/core/splitter_dbs.py#L296" ><!--l. 48--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >destination_of_chunk</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow></mrow><mo 
class="MathClass-close">]</mo></mrow></math></a>
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-50002.2"></a>Joining a team</h4>
                                                                  

                                                                  
<!--l. 8--><p class="noindent" >After connecting with a splitter, incoming peers request (using a reliable communication) to
the splitter the current list of peers in the team. To minimize the joining time, the peer sends
a <!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">hello</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math> message
to each peer of the team, in parallel with the reception of the list. When a peer of the team
receives a <!--l. 13--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">hello</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>,
it adds the sender of the message to a table of peers called
<!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >forward</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow></mrow><mo 
class="MathClass-close">]</mo></mrow></math>. If a peer
<!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math> has an entry
<!--l. 15--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >forward</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>j</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></math> then, each chunk
received by <!--l. 15--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math> and
originated at <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>j</mi></mrow></msub 
></math> will
be forwarded to <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></math>.
</p><!--l. 24--><p class="indent" >   The splitter, in a loop: (1) listens to the incoming peers, (2) sends the list of peers
in the team, and (3) adds the incoming peer to the list.
</p><!--l. 9--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-60002.3"></a>Buﬀering chunks</h4>
<!--l. 8--><p class="noindent" >In order to hide the jitter generated by the physical network and the
protocol itself, peers need to store the received chunks in a buﬀer
during a period of time before playing them. A chunk with number
<!--l. 10--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>x</mi></math> is inserted in the
position <!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">(</mo><mrow><mi 
>x</mi><mi mathvariant="italic">mod</mi><mn>2</mn><mi 
>B</mi></mrow><mo 
class="MathClass-close">)</mo></mrow></math> of the
buﬀer, where <!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math>
is the maximum number of chunks that the buﬀer will store. In a peer’s life,
<!--l. 13--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math> is constant, but diﬀerent
peers can use distinct <!--l. 13--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math>
values.
</p><!--l. 15--><p class="indent" >   The buﬀer is implemented as a circular queue of
<!--l. 15--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>2</mn><mi 
>B</mi></math> chunks, which is
ﬁlled up to only <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math>
chunks in the buﬀering time. Chunks with a higher number (newer chunks) are
inserted in the head of the buﬀer, and viceversa. The chunk pointed by the tail of the
buﬀer is sent to the player. This action is carried out each time a new chunk is
received.
</p><!--l. 22--><p class="indent" >   Chunks can be lost.<span class="footnote-mark"><a 
href="index10.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-6001f9"></a> 
A chunk is considered as lost when it is time to send it to the player and the chunk
has not been received. In this situation, for each lost chunk, the peer sends the
chunk number of the lost chunk (that is the number of the next chunk to be
played) to the neighbor with the smaller chunk debt. This is done using a
<!--l. 29--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">request</mi><mstyle 
class="text"><mtext  >lost_chunk_number</mtext></mstyle></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
                                                                  

                                                                  
message.
</p><!--l. 31--><p class="indent" >   In this situation, it is also possible that some peers can request redundant
paths between an origin peer and itself, and therefore, some chunks could
be received more than once. If this case, for each duplicate chunk, a peer
<!--l. 34--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math> should send
a <!--l. 34--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">prune</mi><mstyle 
class="text"><mtext  >duplicate_chunk_number</mtext></mstyle></mrow><mo 
class="MathClass-close">]</mo></mrow></math> message to
those neighbors that have sent to it the duplicate chunk. Neighbors receiving such message from
peer <!--l. 37--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math> should
remove the <!--l. 37--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>i</mi></mrow></msub 
></math>
from <!--l. 37--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >forward</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>o</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow></math>,
where <!--l. 38--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>o</mi></mrow></msub 
></math>
is the origin peer of the duplicate chunk.
</p><!--l. 47--><p class="indent" >   The buﬀering time determines how much time the peers must wait before start
playing the chunks. Considering that chunks can be lost in transit or delayed more
than <!--l. 49--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>B</mi></math>
times of chunk, randomly, it is diﬃcult to determine, a priori the optimal
buﬀering time. In the current implementation, peers buﬀer a variable number
of chunks that depends on the order in which chunks are received. If
<!--l. 52--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math> is the (number
of the) ﬁrst chunk received (the ﬁrst chunk to be played), the buﬀering time ﬁnishes when
the chunk <!--l. 54--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>x</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-bin">+</mo> <mi 
>B</mi></math> is
received.<span class="footnote-mark"><a 
href="index11.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-6002f10"></a> 
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.4   </span> <a 
 id="x1-70002.4"></a>Chunk ﬂooding</h4>
<!--l. 16--><p class="noindent" >When a peer <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></math>
receives a chunk, <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></math>
ﬂoods a number of chunks to one of its its neighbors (obviously, except the
neighbor sender of the chunk), using a prioritized round-robin schema,
where those peers with a low chunk debt are selected ﬁrst. Every time
<!--l. 19--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></math> sends a
chunk to <!--l. 20--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
></math>,
<!--l. 20--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></math> runs
<!--l. 20--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >debt</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mstyle 
class="text"><mtext  >debt</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-bin">+</mo> <mn>1</mn></math>, and
<!--l. 20--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>l</mi></mrow></msub 
></math> runs
<!--l. 21--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >debt</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mstyle 
class="text"><mtext  >debt</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>k</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-bin">−</mo> <mn>1</mn></math>. Debs are clipped to
<!--l. 22--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-bin">±</mo> <mi 
>D</mi></math>. In ideal circunstances,
debs should be <!--l. 22--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>0</mn></math>.
                                                                  

                                                                  
Obviously, a high supportivity means a low debt, and viceversa.
</p><!--l. 25--><p class="indent" >   <span 
class="ecbx-1000">Note</span>:  The prioritized round-robin neighbor selection has not yet been
implmented.
</p><!--l. 30--><p class="indent" >   DBS is a content-unaware push-based protocol, where when a peer received a
chunk, it can be retransmitted to a large number of neighbors. To avoid network
congestion while ﬂooding, sending peers must perform some kind of data
ﬂow-control.
</p><!--l. 38--><p class="indent" >   Congestion control is performed by means of the basic idea of, <span 
class="ecsl-1000">if I have received a</span>
<span 
class="ecsl-1000">chunk, I should send a chunk</span>. It is easy to see that, in a fully connected
overlay, this allows to control the data ﬂow. However, peers can be “connected”
with a variable number of neighbors and therefore, if the splitter follows
a pure round-robin strategy, some peers can send more chunks that they
receive.
</p><!--l. 45--><p class="indent" >   The previous idea can be improved to handle a variable
connectivity degree. Each peer use an array of FIFO queues,
<!--l. 46--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >pending</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow></mrow><mo 
class="MathClass-close">]</mo></mrow></math>, indexed
by the neighbor end-points, where each queue stores buﬀer positions. Thus, if for example
<!--l. 48--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >pending</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>x</mi></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">{</mo><mrow><mn>1</mn><mn>1</mn><mo 
class="MathClass-punc">,</mo><mn>2</mn><mn>2</mn></mrow><mo 
class="MathClass-close">}</mo></mrow></math>, chunks found
at positions <!--l. 49--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>1</mn><mn>1</mn></math> and
<!--l. 49--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mn>2</mn><mn>2</mn></math> of the buﬀer have
to be sent to peer <!--l. 50--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>x</mi></mrow></msub 
></math>
when the prioritized round-robin scheduler used by the peer select
<!--l. 51--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>x</mi></mrow></msub 
></math>. The
scheduler selects a diﬀerent neighbor for each new received chunk.
                                                                  

                                                                  
</p><!--l. 55--><p class="indent" >   <a 
 id="x1-70013"></a></p><hr class="float" /><div class="float" 
>
                                                                  

                                                                  
 <div style="text-align:center;"> <img width=250 src="graphics/team_0.png" /> </div> 
<br />  <div class="caption" 
><span class="id">Figure 3:    </span><span  
class="content">A    team    has    been    created    with    a    single    monitor
<!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
(<!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">hello</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
messages   are   not   shown).   Chunks   with   numbers   0   and   1   (the   time
<!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>t</mi></math>
is   measured   in   chunks-time)   have   been   transmitted   from   the   splitter
<!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>S</mi></math>
to <!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>.
<!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>F</mi></math>
and <!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>P</mi></math>
represents the <!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >forward</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
and the <!--l. 61--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >pending</mtext></mstyle><mrow ><mo 
class="MathClass-open">[</mo><mrow></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
structures, respectively. The chunks stored in the buﬀer is shown under the
entity.</span></div><!--tex4ht:label?: x1-70013 -->
                                                                  

                                                                  
   </div><hr class="endfloat" />
                                                                  

                                                                  
<!--l. 65--><p class="indent" >   <a 
 id="x1-70024"></a></p><hr class="float" /><div class="float" 
>
                                                                  

                                                                  
 <div style="text-align:center;"> <img width=250 src="graphics/team_1.png" /> </div> 
<br /> <div class="caption" 
><span class="id">Figure 4: </span><span  
class="content">Peer <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
joins the team (the <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">hello</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>’s
are not shown). In <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>,
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>F</mi> <mo 
class="MathClass-rel">=</mo> <mrow ><mo 
class="MathClass-open">{</mo><mrow><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
> <mo 
class="MathClass-punc">:</mo> <mrow ><mo 
class="MathClass-open">[</mo><mrow><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></mrow><mo 
class="MathClass-close">]</mo></mrow></mrow><mo 
class="MathClass-close">}</mo></mrow></math>
because when <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
receives the <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">hello</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
from <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>,
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
is      the      origin      peer      for      all      chunks      received      from
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>S</mi></math>
and <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
is   its   neighbor.   After   that,   when   the   chunk   number   2   arrives   to
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
from <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>S</mi></math>,
an entry <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-punc">:</mo> <mn>2</mn></math>
is created in <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>P</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
for  that  chunk,  and  this  entry  is  deleted  when  the  chunk  2  is  sent  to
<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>.
When <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
receives the chunk 2, <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
inserts the entry <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
> <mo 
class="MathClass-punc">:</mo> <msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
in its forwarding table because <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
considers to <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>M</mi></mrow><mrow 
><mn>0</mn></mrow></msub 
></math>
as a neighbor. Notice that <!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mn>1</mn></mrow></msub 
></math>
does not receive chunks 0 and 1 because these chunks belong to a old section
of the stream.</span></div><!--tex4ht:label?: x1-70024 -->
                                                                  

                                                                  
   </div><hr class="endfloat" />
<!--l. 79--><p class="indent" >   An example of the ﬂooding with congestion control algorithm has been show in
the Figs. <a 
href="#x1-70013">3<!--tex4ht:ref: fig:team_0 --></a>, ..., <span 
class="ecbx-1000">??</span>. Notice that in this example, the debts have not been considered,
and that all messages are received successfully.
</p><!--l. 127--><p class="indent" >   ............
</p><!--l. 129--><p class="indent" >   in DBS is very simple: if a new chunk is received, peers forward (using the
ﬂooding with prunning algorithm described in Sec <span 
class="ecbx-1000">??</span>) each received chunk to the
next peer of their list of peers (following a round-robin pattern).
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.5   </span> <a 
 id="x1-80002.5"></a>Leaving a team</h4>
<!--l. 8--><p class="noindent" >An outgoing peer must to: (1) say <!--l. 8--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">goodbye</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>
to the splitter and the neighbor peers (in this order), (2) relay
any pending (received but yet not sent) chunks, and (3) wait for a
<!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">goodbye</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math> from
the splitter. In case of timeout, the leaving procedure is reset.
</p><!--l. 14--><p class="indent" >   When a peer of the team receives a
<!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">goodbye</mi></mrow><mo 
class="MathClass-close">]</mo></mrow></math>, removes the
sender from the <!--l. 15--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mstyle 
class="text"><mtext  >forward</mtext></mstyle></math>.
</p><!--l. 17--><p class="indent" >   The splitter removes the peer from the list of peers.
</p><!--l. 18--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.6   </span> <a 
 id="x1-90002.6"></a>Free-riding control at splitters</h4>
<!--l. 8--><p class="noindent" >In each team there are a set of <span 
class="ecti-1000">monitors </span>(trusted peers whose behavior is predictable
and that are only known by the splitter), which complain to their splitter with a
<!--l. 10--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mrow ><mo 
class="MathClass-open">[</mo><mrow><mi mathvariant="monospace">lost</mi><mstyle 
class="text"><mtext  >lost_chunk_number</mtext></mstyle></mrow><mo 
class="MathClass-close">]</mo></mrow></math> for
each lost chunk. The splitter only considers these type of messages if they come from
a monitor.
</p><!--l. 14--><p class="indent" >   If a peer <!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>o</mi></mrow></msub 
></math>
accumulates more than <!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>L</mi></math>
losts in <!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>R</mi></math>
rounds, <!--l. 14--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>o</mi></mrow></msub 
></math>
is removed from the splitter’s list of peers. Notice that
<!--l. 15--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>L</mi></math> is proportional
to the number <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi 
>M</mi></math> of
monitors, especially if <!--l. 16--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
><mi 
>P</mi></mrow><mrow 
><mi 
>o</mi></mrow></msub 
></math>
is a gone peer.
</p><!--l. 19--><p class="indent" >   <span 
class="ecbx-1000">Note</span>:  This last functionality has not been implemented, at least, as it has been
explained here. The forget() thread is controlled by a timer, not by a counter of
rounds.
                                                                  

                                                                  
</p><!--l. 33--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-100003"></a>FCS (Free-riding Control Set)</h3>
<!--l. 1--><p class="noindent" >DBS does not imposes any control over the grade of solidarity of the peers. This
means that some selﬁsh peers (on simply peers with reduced connectivity as a
consecuence, for example, of NAT issues) can stay in the team thanks to the
generosity of the rest of peers. If this is unnaceptable, this set of rules forces to
all the peers of the team to share the same number of chunks that they
receive.
</p><!--l. 8--><p class="indent" >   To achieve this behavior, FCS deﬁnes that, if
<!--l. 8--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
mathvariant="bold-script">𝒫</mi></mrow><mrow 
><mi 
>k</mi></mrow><mrow 
><mi 
>j</mi></mrow></msubsup 
></math> realises
that <!--l. 9--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mi mathvariant="monospace">debt</mi><mrow ><mo 
class="MathClass-open">[</mo><mrow><msubsup><mrow 
><mi 
mathvariant="bold-script">𝒫</mi></mrow><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>j</mi></mrow></msubsup 
></mrow><mo 
class="MathClass-close">]</mo></mrow> <mo 
class="MathClass-rel">&#x003E;</mo><msub><mrow 
> <mi mathvariant="monospace">debt</mi></mrow><mrow 
><mstyle 
class="text"><mtext  >max</mtext></mstyle></mrow></msub 
></math>,
then <!--l. 10--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
mathvariant="bold-script">𝒫</mi></mrow><mrow 
><mi 
>k</mi></mrow><mrow 
><mi 
>j</mi></mrow></msubsup 
></math>
removes <!--l. 10--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
mathvariant="bold-script">𝒫</mi></mrow><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>j</mi></mrow></msubsup 
></math>
from <!--l. 10--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
mathvariant="bold-script">𝒯</mi></mrow><mrow 
><mi 
>k</mi></mrow><mrow 
><mi 
>j</mi></mrow></msubsup 
></math>.
Obviously, <!--l. 11--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msubsup><mrow 
><mi 
mathvariant="bold-script">𝒫</mi></mrow><mrow 
><mi 
>l</mi></mrow><mrow 
><mi 
>j</mi></mrow></msubsup 
></math>
should churn, unless it not interested in playing the media.
</p><!--l. 1--><p class="noindent" >
</p>
   <h3 class="likesectionHead"><a 
 id="x1-110003"></a>References</h3>
<!--l. 1--><p class="noindent" >
   </p><div class="thebibliography">
   <p class="bibitem" ><span class="biblabel">
 [1]<span class="bibsp">   </span></span><a 
 id="Xbanerjee2002scalable"></a>Suman Banerjee, Bobby Bhattacharjee, and Christopher Kommareddy.
   <span 
class="ecti-1000">Scalable application layer multicast</span>, volume 32. ACM, 2002.
   </p>
   <p class="bibitem" ><span class="biblabel">
 [2]<span class="bibsp">   </span></span><a 
 id="Xcomer2003computer"></a>Douglas E  Comer  and  Ralph E  Droms.    <span 
class="ecti-1000">Computer  networks  and</span>
   <span 
class="ecti-1000">internets</span>. Prentice-Hall, Inc., 2003.
</p>
   </div>
    
</body> 
</html>
                                                                  


